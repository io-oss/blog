[{"content":"迁移 年前系统升级Monterey版本的时候新增了「快捷指令」APP，当时因为它还不支持shell脚本，只是新奇了一下就没有然后了。今天突然发现「快捷指令」居然也支持shell脚本了，因此就把自己之前用「自动操作」实现的系统增强小工具全迁移到了「快捷指令」上面，一共26个，搞了大半天。之所以迁移，主要是因为「快捷指令」操作更简单、界面更美观、全平台通用，有丰富的官方指令库可用。同时还可以很方便的使用别人的脚本资源或者把自己的脚本分享出去。在使用方式上，除了可以放到服务菜单、触控栏、共享菜单等传统位置之外，还可以固定到菜单栏。\n效果 ","date":"2022-03-26T03:11:17+08:00","permalink":"https://io-oss.gitee.io/blog/p/ab8a1706/","title":"从「自动操作」到「快捷指令」"},{"content":"方法  修改 {user}/.m2/settings.xml\n  通过\u0026lt;mrrior\u0026gt;\u0026lt;/mrrior\u0026gt;配置多个镜像 通过\u0026lt;profile\u0026gt;\u0026lt;/profile\u0026gt;配置多镜像  通过mirror配置时，只有一个仓库会生效，即使这个仓库包不全也不会从其它仓库拉取。profile则可以同时生效多个。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  \u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!-- id必须唯一 --\u0026gt; \u0026lt;id\u0026gt;aliyunRepository\u0026lt;/id\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;aliyun\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!-- id必须唯一 --\u0026gt; \u0026lt;id\u0026gt;companyRepository\u0026lt;/id\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;xxxx\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.92:8081/repository/xxxx/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.92:8081/repository/xxxx/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;!-- 激活myRepository2 --\u0026gt; \u0026lt;activeProfile\u0026gt;companyRepository\u0026lt;/activeProfile\u0026gt; \u0026lt;!-- 激活myRepository1 --\u0026gt; \u0026lt;activeProfile\u0026gt;aliyunRepository\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt;   ","date":"2022-03-22T00:11:08+08:00","permalink":"https://io-oss.gitee.io/blog/p/0ecaf3ee/","title":"Maven多仓库配置"},{"content":"问题记录 MacOS中VirtualBox升级之后虚拟机无法启动 检查系统偏好设置-\u0026gt;安全性与隐私-\u0026gt;通用下有没有需要允许的高风险操作，升级时可能会安装一些服务组件，如果在还没有批准时虚拟机可能无法正常运行\n","date":"2022-01-19T10:56:59+08:00","permalink":"https://io-oss.gitee.io/blog/p/c9c1eb08/","title":"VirtualBox使用记录"},{"content":"作用 开启目录预览之后，在访问某个路径时可以直接显示对应目录下的文件，可以提供文件下载功能。\n实现 1 2 3 4  location /download { alias 下载目录路径; autoindex on; }   在开启目录浏览之后，要注意设置字符集，来避免中文文件/目录名乱码。\n1  charset utf-8;   ","date":"2022-01-19T10:54:58+08:00","permalink":"https://io-oss.gitee.io/blog/p/23ee726e/","title":"Nginx开启目录浏览"},{"content":" root和alias都用于指定目录，但是效果不同\n root 1 2 3  location path{ root /var/www/aa; }   root设置访问路径的根目录，实际访问的路径是/var/www/aa/path\nalias 1 2 3  location aa { alias /var/www/aa; }   alias设置请求路径的别名，实际访问路径/var/www/aa\n","date":"2022-01-19T10:52:48+08:00","permalink":"https://io-oss.gitee.io/blog/p/884bd954/","title":"Nginx中root和alias的区别"},{"content":"添加依赖包  NLog.Web.AspNetCore\n 创建 nlog.config 配置文件 文件名必须是 nlog.config，全小写，且位于项目根目录下，文件生成属性要设置为“复制到输出目录”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; autoReload=\u0026#34;true\u0026#34; internalLogLevel=\u0026#34;Info\u0026#34; internalLogFile=\u0026#34;c:\\temp\\internal-nlog-AspNetCore.txt\u0026#34;\u0026gt; \u0026lt;!-- enable asp.net core layout renderers --\u0026gt; \u0026lt;extensions\u0026gt; \u0026lt;add assembly=\u0026#34;NLog.Web.AspNetCore\u0026#34;/\u0026gt; \u0026lt;/extensions\u0026gt; \u0026lt;!-- the targets to write to --\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;!-- File Target for all log messages with basic details --\u0026gt; \u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;allfile\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-all-${shortdate}.log\u0026#34; layout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${uppercase:${level}}|${logger}|${message} ${exception:format=tostring}\u0026#34; /\u0026gt; \u0026lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --\u0026gt; \u0026lt;target xsi:type=\u0026#34;File\u0026#34; name=\u0026#34;ownFile-web\u0026#34; fileName=\u0026#34;c:\\temp\\nlog-AspNetCore-own-${shortdate}.log\u0026#34; layout=\u0026#34;${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${uppercase:${level}}|${logger}|${message} ${exception:format=tostring}|url: ${aspnet-request-url}|action: ${aspnet-mvc-action}|${callsite}| body: ${aspnet-request-posted-body}\u0026#34; /\u0026gt; \u0026lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --\u0026gt; \u0026lt;target xsi:type=\u0026#34;Console\u0026#34; name=\u0026#34;lifetimeConsole\u0026#34; layout=\u0026#34;${MicrosoftConsoleLayout}\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;!-- rules to map from logger name to target --\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;!--All logs, including from Microsoft--\u0026gt; \u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;allfile\u0026#34; /\u0026gt; \u0026lt;!--Output hosting lifetime messages to console target for faster startup detection --\u0026gt; \u0026lt;logger name=\u0026#34;Microsoft.Hosting.Lifetime\u0026#34; minlevel=\u0026#34;Info\u0026#34; writeTo=\u0026#34;lifetimeConsole, ownFile-web\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --\u0026gt; \u0026lt;logger name=\u0026#34;Microsoft.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;logger name=\u0026#34;System.Net.Http.*\u0026#34; maxlevel=\u0026#34;Info\u0026#34; final=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Trace\u0026#34; writeTo=\u0026#34;ownFile-web\u0026#34; /\u0026gt; \u0026lt;/rules\u0026gt; \u0026lt;/nlog\u0026gt;   更新 Program.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using System; using NLog.Web; namespace ASP.NET_Core_5_NLog_Example { public class Program { public static void Main(string[] args) { var logger = NLog.LogManager.Setup().LoadConfigurationFromAppSettings().GetCurrentClassLogger(); try { logger.Debug(\u0026#34;init main\u0026#34;); CreateHostBuilder(args).Build().Run(); } catch (Exception exception) { //NLog: catch setup errors logger.Error(exception, \u0026#34;Stopped program because of exception\u0026#34;); throw; } finally { // Ensure to flush and stop internal timers/threads before application-exit (Avoid segmentation fault on Linux) NLog.LogManager.Shutdown(); } } public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }) .ConfigureLogging(logging =\u0026gt; { logging.ClearProviders(); logging.SetMinimumLevel(LogLevel.Trace); }) .UseNLog(); // NLog: Setup NLog for Dependency injection } }   修改 appsettings.json 1 2 3 4 5 6 7  \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }   记录日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using Microsoft.Extensions.Logging; public class HomeController : Controller { private readonly ILogger\u0026lt;HomeController\u0026gt; _logger; public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger) { _logger = logger; _logger.LogDebug(1, \u0026#34;NLog injected into HomeController\u0026#34;); } public IActionResult Index() { _logger.LogInformation(\u0026#34;Hello, this is the index!\u0026#34;); return View(); }   异步记录日志 1  \u0026lt;target async=\u0026#34;true\u0026#34;/\u0026gt;   ","date":"2021-12-28T14:49:20+08:00","permalink":"https://io-oss.gitee.io/blog/p/c6394f52/","title":"使用Nlog日志框架"},{"content":"jwt 配置 1 2 3 4 5 6 7 8 9  \u0026#34;JwtSettings\u0026#34;: { # 签发者 \u0026#34;Issuer\u0026#34;: \u0026#34;海拉鲁大魔王\u0026#34;, # 使用者 \u0026#34;Audience\u0026#34;: \u0026#34;海拉鲁大陆\u0026#34;, # 加密密钥 \u0026#34;SecetKey\u0026#34;: \u0026#34;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\u0026#34; }   依赖包  microsoft.aspnetcore.authentication.jwtbearer\n 注册验证服务和处理程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  var jwtSetting = new JwtSettings(); builder.Configuration.GetSection(JwtSettings.Key).Bind(jwtSetting); builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters() { RequireExpirationTime = true, ValidateLifetime = true, ValidIssuer = jwtSetting.Issuer, ValidAudience = jwtSetting.Audience, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSetting.SecetKey)), ClockSkew = new TimeSpan(0, 0, 4) }; });   添加身份验证中间件 1 2 3  //身份验证中间件要添加在其它需要身份验证的中间件前面 app.UseAuthentication(); app.UseAuthorization();   生成 JWT Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var jwtSetting = new JwtSettings(); _configuration.GetSection(JwtSettings.Key).Bind(jwtSetting); var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSetting.SecetKey)); var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); var userName = \u0026#34;userName\u0026#34;; var claim = new Claim[] { new Claim(\u0026#34;name\u0026#34;, userName) }; JwtSecurityToken token = new JwtSecurityToken( issuer: jwtSetting.Issuer, audience: jwtSetting.Audience, claims:claim,expires:DateTime.Now.AddDays(1), signingCredentials:creds); token = new JwtSecurityTokenHandler().WriteToken(token)   ","date":"2021-12-28T11:09:03+08:00","permalink":"https://io-oss.gitee.io/blog/p/07af9947/","title":"Jwt认证"},{"content":"使用场景 快速的构建支持的代码基架。支持 Area、Controller、Identity、RazorPage、View 等。\n用法 添加代码生成全局工具 1  dotnet tool install -g dotnet-aspnet-codegenerator   查看 identity 相关参数 1  dotnet aspnet-codegenerator identity -h   执行生成命令 根据帮助文档中的相关参数说明执行合适的命令来生成代码 比如 Identity，命令如下：\n1 2  dotnet aspnet-codegenerator identity -fi \u0026#34;Account.Login;Account.Logout;Account.Register;Account.Manage._Layout;Account.Manage._ManageNav;Account.Manage._StatusMessage;Account.Manage.ChangePassword;Account.Manage.DeletePersonalData;Account.Manage.Disable2fa;Account.Manage.DownloadPersonalData;Account.Manage.Email;Account.Manage.EnableAuthenticator;Account.Manage.ExternalLogins;Account.Manage.GenerateRecoveryCodes;Account.Manage.Index;Account.Manage.PersonalData;Account.Manage.ResetAuthenticator;Account.Manage.SetPassword;Account.Manage.ShowRecoveryCodes;Account.Manage.TwoFactorAuthentication\u0026#34; --force -u User -dc AuthDbContext   ","date":"2021-12-28T10:50:22+08:00","permalink":"https://io-oss.gitee.io/blog/p/4395076b/","title":"代码生成器的使用方法"},{"content":"程序的国际化和本地化 国际化（Internationalization，I18N）是指将原本针对某一单一语言/文化习俗设计的软件改写成支持多语言/文化习俗的过程。本地化(Localization，L10N)是指适配某一特定语言/文化的过程。国际化和本地化不仅仅是语言翻译的问题，还要考虑文化。比如：文本的书写方向，某一图标在当地文化的理解中与它在程序中想要表达的意义是否一致，时间日期的显示习惯，货币单位，温度单位等。\n简单的本地化实现方案 添加引用 _Imports.razor\n1  @using Microsoft.Extensions.Localization   注册服务和中间件 Program.cs\n1 2 3 4 5 6 7 8 9 10  //注册服务依赖 builder.Services.AddLocalization(o =\u0026gt; o.ResourcesPath = \u0026#34;Resources\u0026#34;); //注册中间件 var supportedCultures = new[] { \u0026#34;zh-CN\u0026#34;, \u0026#34;en\u0026#34;, \u0026#34;en-US\u0026#34; }; var localizationOptions = new RequestLocalizationOptions() .SetDefaultCulture(supportedCultures[0]) .AddSupportedCultures(supportedCultures) .AddSupportedUICultures(supportedCultures); app.UseRequestLocalization(localizationOptions);   创建页面对应的本地化资源文件 页面文件是Index.razor，则对应的本地化文件是Index.zh-CN.resx，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;resheader name=\u0026#34;resmimetype\u0026#34;\u0026gt; \u0026lt;value\u0026gt;text/microsoft-resx\u0026lt;/value\u0026gt; \u0026lt;/resheader\u0026gt; \u0026lt;resheader name=\u0026#34;version\u0026#34;\u0026gt; \u0026lt;value\u0026gt;2.0\u0026lt;/value\u0026gt; \u0026lt;/resheader\u0026gt; \u0026lt;resheader name=\u0026#34;reader\u0026#34;\u0026gt; \u0026lt;value\u0026gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\u0026lt;/value\u0026gt; \u0026lt;/resheader\u0026gt; \u0026lt;resheader name=\u0026#34;writer\u0026#34;\u0026gt; \u0026lt;value\u0026gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\u0026lt;/value\u0026gt; \u0026lt;/resheader\u0026gt; \u0026lt;data name=\u0026#34;PageTitle\u0026#34; \u0026gt; \u0026lt;value\u0026gt;权限控制系统｜首页\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;data name=\u0026#34;H1\u0026#34; \u0026gt; \u0026lt;value\u0026gt;权限控制系统\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;data name=\u0026#34;Title\u0026#34; \u0026gt; \u0026lt;value\u0026gt;系统功能\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;data name=\u0026#34;Content\u0026#34; \u0026gt; \u0026lt;value\u0026gt;维护系统用户信息、角色信息，提供登录验证服务、菜单权限控制服务\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;data name=\u0026#34;Greeting\u0026#34;\u0026gt; \u0026lt;value\u0026gt;欢迎！\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/root\u0026gt;   使用 Index.razor\n1 2 3 4 5 6 7 8 9 10 11 12  @page \u0026#34;/\u0026#34; //注入依赖项 @inject IStringLocalizer\u0026lt;Index\u0026gt; Localizer \u0026lt;PageTitle\u0026gt;@Localizer[\u0026#34;PageTitle\u0026#34;]\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;@Localizer[\u0026#34;H1\u0026#34;]\u0026lt;/h1\u0026gt; @Localizer[\u0026#34;Greeting\u0026#34;] \u0026lt;Document Title=\u0026#34;@Localizer[\u0026#34;Title\u0026#34;]\u0026#34; Content=\u0026#34;@Localizer[\u0026#34;Content\u0026#34;]\u0026#34;/\u0026gt;   本地化资源文件的放置路径 在上面的示例中，资源文件存放在注册服务时指定的专门目录中，这种方式可以很好的组织文件结构，只需要将指定的资源目录看作项目根目录，页面对应的资源文件结构和页面相对于项目根目录的位置保持一致即可。如果在注册服务时，没有指定资源文件路径，则可以将资源文件与页面放在同一个目录中，这样不需要做特殊处理就可以引用相关资源数据，但是这样项目文件相对混乱。\n","date":"2021-12-28T10:36:14+08:00","permalink":"https://io-oss.gitee.io/blog/p/a5d05fb5/","title":"Asp.net Core的国际化和本地化"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;nlog xmlns=\u0026#34;http://www.nlog-project.org/schemas/NLog.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;targets async=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;target name=\u0026#34;logfile\u0026#34; xsi:type=\u0026#34;File\u0026#34; fileName=\u0026#34;${basedir}/logs/${shortdate}.log\u0026#34; layout=\u0026#34;${longdate}|${level:uppercase=true}|${logger}|${threadid}|${message}|${exception:format=tostring}\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;logger name=\u0026#34;*\u0026#34; minlevel=\u0026#34;Info\u0026#34; writeTo=\u0026#34;logfile\u0026#34; /\u0026gt; \u0026lt;/rules\u0026gt; \u0026lt;/nlog\u0026gt;   说明 Nlog会自动检测dll所在目录下名称为Nlog.config的文件，在项目中创建对应的文件，并设置文件属性复制到输出目录值为true，Nlog库即可正常使用。\n","date":"2021-12-08T15:33:33+08:00","permalink":"https://io-oss.gitee.io/blog/p/812fe352/","title":"Nlog配置文件模板"},{"content":" 需要做数量配置的主要有两方面，时间和数据量。\n 数据量单位 数据量可以指定为字节（byte）、千字节（kilobyte，后缀k或者K）或者兆（megabytes，后缀m或者M），例如：1024，8k，1m\n时间单位 时间间隔可以用毫秒（millisecond）、秒（minute）、小时（hour）、天（day）等等，使用下列后缀：\n   单位 后缀     毫秒 ms   秒 s   分 m   小时 h   天 d   星期 w   月 m   年 y    多个单位可以混合使用，分隔符通过空格分割，例如1h 30m等同于90m或者5400s。推荐使用同一种单位。\n","date":"2021-11-17T10:00:20+08:00","permalink":"https://io-oss.gitee.io/blog/p/9388652f/","title":"Nginx配置文件中的度量单位"},{"content":"Windows C:\\Users\\用户名\\AppData\\Roaming\\JetBrains\\\nMacOS ~/Library/Application Support/JetBrains/\nLinux ~/.config/JetBrains/\n","date":"2021-09-22T11:01:57+08:00","permalink":"https://io-oss.gitee.io/blog/p/bf8d76a9/","title":"JetBrains配置文件位置"},{"content":"效果 删除某一个Homebrew包的时候，同时删除这个包的依赖项，但跳过被其它包依赖的项。\n实现 安装rmtree工具\n1  brew tap beeftornado/rmtree \u0026amp;\u0026amp; brew install brew-rmtree   用法\n1  brew rmtree \u0026lt;package\u0026gt;    某些包在打包的时候可能没有正确的写好依赖，此时它依赖的内容可能因此被删掉。\n ","date":"2021-09-03T17:58:36+08:00","permalink":"https://io-oss.gitee.io/blog/p/3e95dfc6/","title":"删除Homebrew包同时移除依赖项"},{"content":"命令 1  top   效果 top命令经常用来监控系统状况，通过这个命令可以查看cpu、内存等关键信息的使用情况。运行效果如图示：\n说明 第一行中：09:26:59是当前的系统时间，44 days，18:21表示已运行了44天18小时21分钟。2 users表示当前有两个用户登录系统。load average: 28.60, 22.79, 22.15三个数值表示1分钟、5分钟、15分钟内的CPU负载情况。理想状态下，CPU满负荷工作、并且没有等待进程，此时平均负载=1*逻辑核心数；但是在实际生产系统中，不建议系统满负荷运行，一般的经验是要小于平均负载=0.7*逻辑核心数这个标准，如果平均负载持续大于这个标准，就需要开始调查原因，防止系统恶化；如果持续大于平均负载=1*逻辑核心数，就必须要找解决方法，降低平均负载；如果负载数持续大于平均负载=5*逻辑核心数的标准，表明系统已出现严重问题，长时间未响应，或者接近死机。\n 关于CPU负载，除了要关注CPU负载的绝对值，还要关注CPU负载的变化趋势。如果CPU负载的三个值很接近，表明短期内系统负载稳定，这时需要关注与昨日或者上周负载情况的对比。如果1分钟内的负载远低于过去5分钟或15分钟内的负载，可以理解为系统负载情况正在转好。如果1分钟内的负载远大于过去5分钟或15分钟的负载值，说明系统状况正在趋于恶化，此时就需要关注是否是临时性的抖动，若不是，就需要积极调查原因降低负载。\n 第二行中显示的是系统进程信息，表示当前总进程数（total）313个、进行中的进程数（running）1个、休眠中（sleeping）的312个、已终止（stopped）0个、僵尸状态（zombie）的0个。\n第三行中的是CPU使用率，96.1 us-用户空间CPU占比、3.5 sy-内核空间CPU占比、0.0 ni-改变过优先级的进程CPU占比、0.0 id-空闲CPU占比、0.0 wa-IO等待CPU占比、0.0 hi-硬件中断CPU占比、0.4 si-软中断CPU占比、0.0 st-和虚拟机有关，数值越大表示CPU被宿主机或者其它虚拟机占用的时间越长。\n第四行是内存状态信息，total是物理内存总量，free是空闲内存总量，used是使用中的内存总量。buff/cache是缓冲区占用内存总量，系统实际可用内存可以理解为free+buff/cache。第五行是swap交换分区的信息，total是交换区总量，free是空闲交换区总量，used是使用的量。如果交换区的used数据一直在变化，那就说明系统内存真的不够用了。\n","date":"2021-09-02T09:29:34+08:00","permalink":"https://io-oss.gitee.io/blog/p/1372114a/","title":"Linux Top 命令解析"},{"content":"目标 创建一个RESTful API。\n实现 在IDEA中创建Spring项目  通过srping initializr来初始化项目 依赖项要增加spring web  创建 RESTful API 1 2 3 4 5 6 7  @RestController public class IndexController { @RequestMapping(\u0026#34;/\u0026#34;) public String index() { return \u0026#34;hello, there\u0026#34;; } }      @RestController和@Controller注解的区别： 加@Controller注解的类里的每个方法都将返回一个视图页面；加@RestController注解则数据会以json/xml的形式返回前台页面；@Controller加@ResponseBody则与@RestController效果一样。加@RestController注解则不能返回jsp、html页面。\n  @RequestMapping注解，在不指定请求谓词的情况下Post和Get都支持，可以通过method指定请求方式\n1 2 3 4  @RequestMapping( method = RequestMethod.GET, // .post 　path = \u0026#34;/\u0026#34; )   还可以直接通过@GetMapping(\u0026quot;/\u0026quot;)/@PostMapping(\u0026quot;/\u0026quot;)来指定请求方式和路由\n   指定服务启动端口 修改src/main/resources/application.properties文件，通过server.port=*****来指定启动端口\n","date":"2021-07-06T10:07:10+08:00","permalink":"https://io-oss.gitee.io/blog/p/96fc722c/","title":"用 Spring 创建 RESTful Web Service"},{"content":"什么是classpath 一般情况下基于Maven的Java项目开发阶段目录结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  src -main –java java源代码文件 –resources 资源库，会自动复制到classes目录里 –filters 资源过滤文件 –webapp web应用的目录。WEB-INF、css、js等 –test –java 单元测试java源代码文件 –resources 测试需要用的资源库 –filters 测试资源过滤库 –assembly 组件的描述配置（如何打包） –it 集成测试(主要用于插件) –site Site（一些文档） target pom.xml maven的pom文件 LICENSE.txt Project’s license README.txt Project’s readme   发布后的目录结构：\n1 2 3 4 5  jar -META-INF -BOOT-INF -classes -lib   其中开发时期的src/main/下面的java和resources文件夹都被打包到了生产包的BOOT-INF/classes/目录下，由maven引入的依赖都被放入到了BOOT-INF/lib/下面。classpath指的就是BOOT-INF目录下的classes文件夹。\nclasspath的作用 classpath一般用于指定配置或者资源的路径，比如在配置mybatis的Mapper.xml文件位置时：\n1  classpath*:**/mapper/mapping/*Mapper.xml   classpath*表示可以匹配多个文件，路径中的**表示在BOOT-INF/classes/下的任意下层目录。\n","date":"2021-06-28T11:49:22+08:00","permalink":"https://io-oss.gitee.io/blog/p/139dc015/","title":"Java项目中的classpath是什么"},{"content":"  Spring profile 条件化的bean声明 自动装配与歧义性 bean的作用域 Spring表达式语言   环境与profile 软件运行在不同的环境，需要装配不同的bean。比如：在开发环境、QA环境和生产环境可能会用到不同类型的数据库配置。\n常规的处理手段是构建针对性的独立配置类（或者XML），在构建阶段确定要将哪一个配置编译到应用中。这种方式需要为每种环境重新构建应用，这将导致各种问题，比如从QA阶段迁移到生产环境时，重新构建可能会引入BUG。\nSpring提供了不需要重新构建的解决方案。首先，在Java配置中，通过**@Profile**注解来指定某个bean属于哪一个Profile（或者在XML配置中通过\u0026lt;beans\u0026gt;元素的profile属性置顶）；然后，用spring.profiles.active和spring.profiles.default 来指定激活的profile和默认的profile（激活和默认的profile可以同时指定多个）。\n 指定了profile的bean只有在对应的profile被激活时才会被创建。没有指定profie的bean始终都会被创建。\n 设置active和default属性的方式\n 作为DispatcherServlet的初始化参数； 作为Web应用的上下文参数； 作为JNDI条目； 作为环境变量； 作为JVM的系统属性； 在集成测试类上，使用@ActiveProfiles注解设置。  条件化的bean 有些时候，对于某些bean，我们希望只有在某些特定的情况满足之后在创建这个bean。Spring提供了**@Conditional**注解来实现根据条件动态配置bean的功能。\n1 2 3 4 5  @Bean @Conditional(MagicExistsCondition.class) public MagicBean magicBean(){ return new MagicBean(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package com.habuma.restfun; import org.springframework.context.annotation.Condition; import org.springframework.context.annotation.ConditionContext; import org.springframework.core.env.Environment; import org.springframework.core.type.AnnotatedTypeMetadata; public class MagicExistsCondition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { Environment env = context.getEnvironment(); return env.containsProperty(\u0026#34;magic\u0026#34;); } }   当matches()方法返回true时bean才会被创建。\n处理自动装配的歧义   通过**@Primary**注解，设置首选bean（XML中对应的是\u0026lt;bean\u0026gt;元素的bool型属性primary）\n  通过**@Qualifier**注解，指定注入时要选中的bean\n1 2 3 4 5  @Autowired @Qualifier(\u0026#34;iceCream\u0026#34;) public void setDessert(Dessert dessert) { this.dessert = dessert; }    @Qualifier注解所设置的参数就是要注入bean的ID\n   使用自定义限定符 bean的ID和默认的限定符会因类名的修改而发生变化，从而导致自动装配失败，可以在bean声明上添加**@Qualifier**注解来设置自定义的限定符。\n使用自定义限定符注解  使用自定义的限定符，还是会遇到指向多个可选bean的情况，这个时候需要增加多个限定符来进一步缩小范围，但是Java不允许同一个条目上出现相同类型的多个注解。针对这种情况，Spring提供了自定义限定符注解的能力。\n 1 2 3 4 5  @Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Qualifier public @interface Cold { }   在使用时不再用**@Qualifier(\u0026ldquo;cold\u0026rdquo;)**，而是使用自定义的@Cold注解,这样就就可以在同一个条目上增加多个自定义注解，将可选范围缩小到只有一个bean满足需求。\n1 2 3 4 5 6  @Autowired @Cold @Creamy public void setDessert(Dessert dessert) { this.dessert = dessert; }   bean的作用域 默认情况下，Spring应用上下文中的bean都是以单例形式创建的——不论给定的bean被注入到其它的bean多少次，每次注入的都是同一个实例。\n一般情况下，单例模式就能满足需求。但是仍有单例模式不适用的场景。\nSpring定义的作用域：\n 单例（Singleton）：整个应用只创建bean的一个实例。 原型（Prototype）：每次注入或者通过Spring应用上下文获取都会创建一个新的bean实例。 会话（Session）：在Web应用中，为每个会话创建一个bean实例。 请求（Request）：在Web应用中，为每个请求创建一个bean实例。  设定作用域要使用**@Scope**注解。\n1 2 3  @Component @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class Notepad { ... }   对应的XML配置\n1 2 3  \u0026lt;bean id=\u0026#34;notepad\u0026#34; class=\u0026#34;com.myapp.Notepad\u0026#34; scope=\u0026#34;prototype\u0026#34; /\u0026gt;   会话和请求作用域 会话作用域例子-购物车\n1 2 3 4 5  @Component @Scope( value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES) public ShoppingCart cart() { ... }   value设置成了WebApplicationContext中的SCOPE_SESSION常量（它的值是session），表示Spring需要为Web应用中的每一个会话创建一个ShopeingCart。\nproxyMode设置成ScopedProxyMode.INTERFACES。用于解决将会话货请求作用域的bean注册到单例bean中遇到的问题。\n假设存在一个单例的StoreService bean：\n1 2 3 4 5 6 7 8 9  @Component public class StoreService { @Autowired public void setShoppingCart(ShoppingCart shoppingCart) { this.shoppingCart = shoppingCart; } ... }   StoreService作为一个单例bean，会在应用上下文加载时创建，当它创建时又会试图将ShoppingCart bean注入到setShoppingCart()方法。而ShoppingCart bean又是会话作用域，需要有用户进入系统，创建了会话之后才会出现其实例。proxyMode设置为ScopedProxyMode.INTERFACES之后，Spring会注入一个到ShoppingCart的代理，这个代理暴露的方法与ShoppingCart相同，当StoreService调用ShoppingCart方法是，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。\n proxyMode设置成ScopedProxyMode.INTERFACES时，要求ShoppingCart时接口，而不是类。如果是一个具体的类，需要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS。\n 运行时值注入  属性占位符（Property placeholder） Spring表达式语言  注入外部值  使用**@PropertySource**注解和Environment：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package com.soundsystem; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.core.env.Environment; @Configuration @PropertySource(\u0026#34;classpath:/com/soundsystem/app.properties\u0026#34;) public class EnvironmentConfig { @Autowired Environment env; @Bean public BlankDisc blankDisc() { return new BlankDisc( env.getProperty(\u0026#34;disc.title\u0026#34;), env.getProperty(\u0026#34;disc.artist\u0026#34;)); } }   @PropertySource注解引用路径对应的属性文件会加载到Spring的Environment中。\nEnvironment中getProperty()方法的重载：   String getProperty(String key) String getProperty(String key,String defaultValue) T getProperty(String key,Class type) T getProperty(String key,Class type,T defaultValue)   占位符\nXML中的属性占位符：\n  1 2 3 4  \u0026lt;bean id=\u0026#34;sgtPeppers\u0026#34; class=\u0026#34;soundsystem.BlankDisc\u0026#34; c:_title=\u0026#34;${disc.title}\u0026#34; c:_artist=\u0026#34;${disc.artist}\u0026#34; /\u0026gt;   Spring表达式语言  SpEL（Spring Expression Language，SpEL）表达式要放到“#{ ··· }”之内，格式上与属性占位符类似。\n   使用bean的ID来引用bean\n1  #{sgtPeppers.artist}     调用方法和访问对象的属性\n1  #{T(System).currentTimeMillis()}     对值进行算术、关系和逻辑运算\n1  #{2 * T(java.lang.Math).PI * circle.radius}     正则表达式匹配\n1  #{admin.email matches \u0026#39;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.com\u0026#39;}     集合操作\n1  #{jukebox.songs[4].title}     ","date":"2021-06-03T17:13:10+08:00","permalink":"https://io-oss.gitee.io/blog/p/de06998b/","title":"高级装配"},{"content":" 自动操作是系统自带软件，可以将一些重复性的工作自动化。\n 功能使用 Shell脚本接收参数   自变量获取参数\n  stdin获取参数   故障排除 Shell脚本部分命令不识别  查看选择的Shell类型是否合适。 在脚本前面加入source ~/.bash_profile,引入环境变量配置。  ","date":"2021-05-28T13:31:34+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210528111008.webp","permalink":"https://io-oss.gitee.io/blog/p/375e7a13/","title":"自动操作（Automator）"},{"content":" 创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质\n Spring配置方案  在XML中进显式配置 在Java中进行显式配置 隐式的bean发现机制和自动装配  选择Spring装配方案时，要根据实际情况选择自己最喜欢的方式，多种方案还可以搭配使用。要尽可能的使用自动配置机制，显式配置越少越好；当必须要使用显式配置时，优先JavaConfig；只有在想使用便利的XML命名空间而且在JavaConfig中没有同样的实现时，才使用XML。\n自动化装配bean Spring从两个角度来实现自动化装配：\n 组件扫描（Component scanning）：Spring会自动发现应用上下文中所创建的bean。 自动装配（autowiring）：Spring自动满足bean之间的依赖。  创建可被发现的bean 创建组件类 在类上加@Component注解，就表明这个类会作为组件类、并告知了Spring要为这个类创建bean。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package soundsystem; import org.springframework.stereotype.Component; @Component public class SgtPeppers implements CompactDisc { private String title = \u0026#34;Sgt. Pepper\u0026#39;s Lonely Hearts Club Band\u0026#34;; private String artist = \u0026#34;The Beatles\u0026#34;; public void play() { System.out.println(\u0026#34;Playing \u0026#34; + title + \u0026#34; by \u0026#34; + artist); } }   开启组件扫描 组件扫描默认不启用，需要显式配置来命令Spring扫描带有@Component注解的类、并为之创建bean。\n  通过Java配置类启用组件扫描\n1 2 3 4 5 6 7 8  package soundsystem; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan public class CDPlayerConfig { }   配置类不需要显式声明bean，只需要@ComponentScan注解即可，默认会扫描配置类相同的包和子包下的加@Component注解的类。\n  通过XML启用组件扫描\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;soundsystem\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt;     设置bean的ID   默认ID\nSpring默认会用首字母变小写的类名作为bean的ID\n  @Component注解参数设置ID @Component注解可以接收一个字符串作为ID\n1 2 3 4  @Component(\u0026#34;lonelyHeartsClub\u0026#34;) public class SgtPeppers implements CompactDisc { ... }     @Named注解设置ID\n1 2 3 4 5 6 7  package soundsystem; import javax.inject.Named; @Named(\u0026#34;lonelyHeartsClub\u0026#34;) public class SgtPeppers implements CompactDisc { ... }   @Named与@Component注解在大多数场景中可以相互替换，但是@Component更便于理解意图\n  设置组件扫描的对象 实际项目中组件扫描不能仅仅扫描配置类所在的包，这就要手动指定扫描对象。\n  在@ComponentScan注解指明包名称\n1 2 3  @Configuration @ComponentScan(\u0026#34;soundsystem\u0026#34;) public class CDPlayerConfig {}     更加清晰的表明是在设置基础包\n1 2 3  @Configuration @ComponentScan(basePackages=\u0026#34;soundsystem\u0026#34;) public class CDPlayerConfig {}     指定多个基础包\n1 2 3  @Configuration @ComponentScan(basePackages={\u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;}) public class CDPlayerConfig {}     上面的指定方式用String处理基础包名称，类型不安全（not type- safe），很容易在代码重构时出错。@ComponentScan还提供了一种类型安全的处理方式\n1 2 3  @Configuration @ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class}) public class CDPlayerConfig {}   bean自动装配的实现  自动装配：让Spring自动满足bean依赖。在自动装配过程中，会在Spring上下文中寻找匹配某个bean需求的其它bean。\n 使用__@Autowired__注解来声明要进行自动装配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  package soundsystem; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class CDPlayer implements MediaPlayer { private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) { this.cd = cd; } public void play() { cd.play(); } }   除了构造器,__@AutoWired__注解还可用于类的任何方法上：\n1 2 3 4  @Autowired public void setCompactDisc(CompactDisc cd) { this.cd = cd; }   在应用上下文创建时，Spring会尝试满足所有__@AutoWired__注解声明的参数依赖。\n 如果有且只有一个bean匹配依赖的需求，那这个bean会被装配。 如果没有匹配的bean，应用上下文创建时会抛出异常。 如果注解设置成**@AutoWired(required=false)**，Spring会尝试自动装配，若没有匹配bean就会让这个bean处于未装配状态，而不会报错（对于可能未装配的bean要注意做null检查）。 如果有多个bean满足以依赖关系，会抛出异常（没有明确指定要选择哪个bean进行自动装配）   @AutoWired注解是Spring特有的，如果不愿意代码中到处使用Spring的特定注解来完成自动装配任务，可以用**@Inject替换。@Inject注解来源于Java依赖注入规范，与@AutoWired**有细微差别，但是大多数场景可以互相替换。\n   自动扫描和自动装配可以满足大部分应用场景，但是部分场景仍需要显式配置。比如要将第三方库中的组件装配到自己的应用中，此时没办法修改第三方库、增加@Component和@AutoWired**注解，一次要采用显示装配方案。\n 通过Java代码装配bean 创建配置类 1 2 3 4 5 6  package soundsystem; import org.springframework.context.annotation.Configuration; @Configuration public class CDPlayerConfig { }   配置类的关键在于**@Configuration注解，与自动装配的配置类的区别在于移除了组件扫描注解@ComponentScan**。\n声明简单的bean 1 2 3 4  @Bean public CompactDisc sgtPeppers() { return new SgtPeppers(); }   @Bean表明此方法会返回一个对象，并且这个对象需要注册为Spring应用上下文中的bean。最中产生bean实例的逻辑包含在方法体中。\n 默认情况下bean的ID与带有Bean注解的方法名一致。如果要自己指定可以用@Bean(name=\u0026quot;customName\u0026quot;)注解方式来指定\n 借助JavaConfig实现依赖注入 假设CDPlayerbean依赖于之前声明的beanCompactDisc,则这样装配：\n1 2 3 4  @Bean public CDPlayer cdPlayer() { return new CDPlayer(sgtPeppers()); }    此处的CompactDisc看似是调用sgtPeppers()得到的，实际上因为sgtPeppers()加了@Bean注解，Spring会拦截所有对此方法的调用，并确保直接返回此方法所创建的bean，而不是每次都实际调用。\n 构造器注入bean：\n1 2 3 4  @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) { return new CDPlayer(compactDisc); }   通过Setter方法注入：\n1 2 3 4 5 6  @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) { CDPlayer cdPlayer = new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc); return cdPlayer; }   通过XML装配bean Spring刚出现时，XML是描述配置的主要方式，所以现存大量基于XML的Spring配置。因此虽然现在有了自动化配置和基于Java的配置，要想更好的维护已有的XML配置，就需要了解XML配置方式。\n创建XML配置规范 使用JavaConfig时，要创建一个带有**@Configuration**注解的类，与此对应的操作，是创建一个XML文件，并且要以\u0026lt;beans\u0026gt;元素为根。以spring-beans模式装配bean的最基本XML：\n1 2 3 4 5 6 7 8 9  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context\u0026#34;\u0026gt; \u0026lt;!-- configuration details go here --\u0026gt; \u0026lt;/beans\u0026gt;   声明一个简单\u0026lt;bean\u0026gt;   简单bean的声明\n1  \u0026lt;bean class=\u0026#34;soundsystem.SgtPeppers\u0026#34; /\u0026gt;     指定bean的名字（id）\n1  \u0026lt;bean id=\u0026#34;compactDisc\u0026#34; class=\u0026#34;soundsystem.SgtPeppers\u0026#34; /\u0026gt;     借助构造器注入初始化bean   \u0026lt;constructor-arg\u0026gt;元素\n1 2 3  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;compactDisc\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt;     c-命名空间\n c-命名空间是Spring3.0引入的，可以在XML中更简洁的描述构造器参数。\n 要使用c-命名空间需要在XML顶部声明其模式：\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; ... \u0026lt;/beans\u0026gt;   声明构造器参数：\n1 2  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34; c:cd-ref=\u0026#34;compactDisc\u0026#34; /\u0026gt;    属性名以“c:”开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后是“-ref”，这是一个命名的约定，它会告诉Spring，正在装配的是一个bean的引用，这个bean的名字是compactDisc。\n 需要注意的是构造器参数名，直接写参数名在某些情况下会导致错误，替代方案是使用参数在整个参数列表中的位置信息：\n1 2  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34; c:_0-ref=\u0026#34;compactDisc\u0026#34; /\u0026gt;   如果构造器中只有一个参数，还可以写成：\n1 2  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34; c:_-ref=\u0026#34;compactDisc\u0026#34; /\u0026gt;     借助属性的Setter方法注入 假设注入对象CDPlayer如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package soundsystem; import org.springframework.beans.factory.annotation.Autowired; import soundsystem.CompactDisc; import soundsystem.MediaPlayer; public class CDPlayer implements MediaPlayer { private CompactDisc compactDisc; @Autowired public void setCompactDisc(CompactDisc compactDisc) { this.compactDisc = compactDisc; } public void play() { compactDisc.play(); } }   对此类的Spring bean声明：\n1 2 3 4  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;compactDisc\u0026#34; ref=\u0026#34;compactDisc\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt;   与构造器注入中Spring为\u0026lt;constructor-arg\u0026gt;提供了简洁的c-命名空间替代方案类似，Spring为属性注入提供了p-命名空间的替代方案。\n首先要声明p-命名空间\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; ... \u0026lt;/beans\u0026gt;   属性装配：\n1 2 3  \u0026lt;bean id=\u0026#34;cdPlayer\u0026#34; class=\u0026#34;soundsystem.CDPlayer\u0026#34; p:compactDisc-ref=\u0026#34;compactDisc\u0026#34; /\u0026gt;   p-命名空间的命名约定与c-命名空间类似：\n导入和混合配制 在典型的Spring应用中，经常会同时使用自动配置和显式配置，在Spring中这些配置都不是互斥的。\n  在JavaConfig中引入XML配置\n  在XML配置用引入JavaConfig\n  这两种混合模式都是支持的。\n","date":"2021-05-27T15:15:20+08:00","permalink":"https://io-oss.gitee.io/blog/p/a6324888/","title":"装配Bean"},{"content":"Spring是什么 Spring是一个为了解决企业级应用开发的复杂性而创建的开源框架。\nSpring降低Java开发复杂性的4种关键策略\n 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码。  基于POJO Spring代码仍旧是POJO，除了某些类会用到Spring注解，不会感觉到使用Spring的任何痕迹。\n依赖注入（DI） 依赖注入可以使应用对象之间保持松散耦合。\n应用切面 面向切面编程可以把遍布应用各处的功能分离出来，形成可重用组件。面向切面编程往往被定义为促使软件系统实现关注点分离的一项技术。\n使用模板 通过模板封装来消除样板式代码（比如JDBC操作）。\nSpring容器 在Spring中，应用对象生存于Spring容器（container）中。容器负责创建对象，装配它们，配置并管理它们的整个生命周期，从生存到死亡（new到finalize()）。容器是使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。\nSpring自带了两类容器，bean工厂 和 应用上下文。bean工厂是最简单的容器，提供了基本的DI支持。应用上下文基于bean工厂构建，并提供应用框架级别的服务。bean工厂太过低级，，应用上下文要比bean工厂更受欢迎。\n应用上下文 常见的应用上下文\n   类型 作用     AnnotationConfigApplicationContext 从一个或多个基于Java的配置类中加载Spring应用上下文   AnnotationConfigWebApplicationContext 从一个或多个基于Java的配置类中加载Spring Web应用上下文。   ClassPathXmlApplicationContext 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。   FileSystemXmlApplicationContext 从文件系统下的一个或多个XML配置文件中加载上下文定义。   XmlWebApplicationContext 从Web应用下的一个或多个XML配置文件中加载上下文定义。    bean的生命周期 Spring功能概览 Spring框架通过专注于DI和AOP和消除样板代码来简化企业级Java开发，这只是Spring提供的部分功能。Spring框架是一个庞大的生态圈，它涵盖了多个不同领域，例如Web服务、REST、移动开发以及NoSQL等。\n","date":"2021-05-20T15:16:06+08:00","permalink":"https://io-oss.gitee.io/blog/p/006e1380/","title":"初步了解Spring"},{"content":"步骤  设计图标  尺寸要求1024*1024的\n创建图片存放目录  mkdir AppIcon.iconset\n名字随便，但是必须有.iconset后缀\n将原图标转为各种尺寸  1 2 3 4 5 6 7 8 9 10  sips -z 16 16 AppIcon.png --out AppIcon.iconset/icon_16x16.png sips -z 32 32 AppIcon.png --out AppIcon.iconset/icon_16x16@2x.png sips -z 32 32 AppIcon.png --out AppIcon.iconset/icon_32x32.png sips -z 64 64 AppIcon.png --out AppIcon.iconset/icon_32x32@2x.png sips -z 128 128 AppIcon.png --out AppIcon.iconset/icon_128x128.png sips -z 256 256 AppIcon.png --out AppIcon.iconset/icon_128x128@2x.png sips -z 256 256 AppIcon.png --out AppIcon.iconset/icon_256x256.png sips -z 512 512 AppIcon.png --out AppIcon.iconset/icon_256x256@2x.png sips -z 512 512 AppIcon.png --out AppIcon.iconset/icon_512x512.png sips -z 1024 1024 AppIcon.png --out AppIcon.iconset/icon_512x512@2x.png   生成icns文件  iconutil -c icns AppIcon.iconset -o AppIcon.icns\n经过这几个步骤，就生成了可用的App图标，然后在APP的简介界面替换就行了\n效果 原图标\n修改后\n","date":"2021-04-28T12:19:35+08:00","permalink":"https://io-oss.gitee.io/blog/p/1844ba76/","title":"自制App图标"},{"content":" 首先要明确一点，针对同一个场景的正则表达式并不是唯一的，只要结果正确即可，不要疑惑为什么自己写的正则跟别人的不一样\n 匹配确定的值 值是什么表达式就是什么。\n1 2  # 匹配字母‘A’ A   匹配一些值 用方括号将值包裹起来\n1 2  # 匹配姓张的和姓王的 [张王]\\w+   1 2 3 4 5 6 7 8  # 匹配数字 [0-9] # 匹配中文 [\\u4e00-\\u9fa5] # 区间取非 # ^只有在‘[]’中且紧跟在‘[’之后才表示取非 # 例：非数字 [^0-9]    元字符：有特殊含义的字符，比如在‘[]’中的连字符‘-’，表示取连字符左右两边值之间的内容。若要取元字符本身的含义，需要用转移字符‘\\’进行转义。若用转义字符对普通字符转义，则普通字符将被理解成元字符，比如匹配换行符‘\\n’。\n 匹配所有值 英文句号.\n匹配次数控制 匹配确定的次数 匹配一次 表达式默认匹配一次，不需要做任何特殊操作\n匹配n次 表达式加‘{n}’\n匹配m次到n次 表达式加‘{m,n}’\n匹配不确定的次数 匹配1到多次 表达式加‘+’\n1 2  # 匹配一组数字 \\d+   匹配0到多次 1 2  # 匹配0到多个字符 \\w*   匹配0次或1次 表达式加‘?’\n1 2  # 匹配网址 https?//[\\w./]+   边界 单词边界 \\b\n字符串边界 ^\\w+$\n","date":"2021-04-24T21:27:56+08:00","permalink":"https://io-oss.gitee.io/blog/p/6de70ddc/","title":"正则表达式常用规则"},{"content":"客户端终结点配置 1 2 3 4 5 6 7 8 9 10  \u0026lt;system.serviceModel\u0026gt; \u0026lt;bindings\u0026gt; \u0026lt;basicHttpBinding\u0026gt; \u0026lt;binding name=\u0026#34;MISServiceHttpBinding\u0026#34; maxBufferSize=\u0026#34;2147483647\u0026#34; maxReceivedMessageSize=\u0026#34;2147483647\u0026#34;/\u0026gt; \u0026lt;/basicHttpBinding\u0026gt; \u0026lt;/bindings\u0026gt; \u0026lt;client\u0026gt; ... \u0026lt;/client\u0026gt; \u0026lt;/system.serviceModel\u0026gt;   ","date":"2021-04-09T12:03:53+08:00","permalink":"https://io-oss.gitee.io/blog/p/74cc3c3c/","title":"关于Web Service"},{"content":"起步 本章为Git入门。主要讲解为什么Git这么流行，为什么要使用Git，Git如何设置\n 关于版本控制 记录一个或多个文件内容变化，以便将来阅读特定版本修订情况的系统即版本控制系统（VCS）。\n本地版本控制系统 本地版本控制系统大多都是采用某种简单的数据库来记录文件的历次更新差异，如图所示：\n其中最流行的一种叫做RCS。RCS的工作原理是在硬盘上保存补丁集（补丁集是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。本地版本控制系统无法让不同系统上的开发者协同工作。\n集中化的版本控制系统 集中化版本控制系统（Centralized Version Control System，CVCS）很好的解决了本地版本控制系统不能让不同系统上的开发者协同工作的问题。CVCS模式：有一个单一的集中管理服务器，保存所有文件的修订版本，协同工作的人都通过客户端连接到这台服务器，取出最新文件或者提交更新。\nCVCS的优点：1.项目参与者可以看到其他人在做什么。2.管理人员可以掌控每个参与者的权限。3.管理一个CVCS相较于在各个客户端维护本地数据库要简单。\nCVCS的缺点：中央服务器故障后会影响所有人的工作。\n典型的CVCS：CVS，Subversion，Perforce\u0026hellip;\n分布式版本控制系统 分布式版本控制系统（Distributed Version Control System，DVCS）中，客户端不仅仅提取最新版本的文件，还把代码仓库完整的镜像下来，包括完整的历史记录。在分布式版本控制系统中，任何一处服务器发生故障，事后都可以用任意一个镜像出来的本地仓库恢复。\n典型的DVCS：Git，Mercurial，Bazaar，Darcs\u0026hellip;\n Git的诞生 Linux开源社区的BitKeeper（一款DVCS）使用权到期了，他们只好去开发自己的版本控制系统😂，并且给新系统制定了若干目标：\n 速度 简单的设计 对非线性开发模式的强力支持 完全分布式 有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）   Git的工作原理 直接记录快照、而非比较差异 Git和其它版本控制系统的主要差别在于对待数据的方式。其它大部分系统一文件变更列表的方式存储信息，将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。\nGit则更像是把数据看作是对小型文件系统的一系列快照。每当你提交更新或者保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git不再重新存储该文件，而是保留一个链接指向之前存储的文件。Git对待数据更像是一个快照流。\n近乎所有操作都是本地执行 Giit中大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息，因为本地磁盘上就有项目的完整历史，同时Git是先提交到本地副本，再上传到服务器的，所以即使离线也可以继续进行任何操作。\nGit保证完整性 Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。\nGit用于计算校验和的机制叫做SHA-1散列（Hash，哈希，把任意长度的输入「又叫做预映射pre-image」通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值）。这是一个由40个16进制字符（0-9，a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1 Hash 看起来是这样的：24b9da6552252987aa493b52f8696cd6d3b00373\nGit中保存的信息都是以文件的Hash值来索引，而不是文件名。\nGit一般只添加数据 你执行的Git操作几乎只向数据库中添加数据，也就是说Git几乎不会执行任何不可恢复操作。\n三种状态  已修改（modified） 已暂存（staged） 已提交（committed）  已修改表示修改了文件，但是还没有保存到数据库。已暂存表示对一个已修改文件的当前版本做了标记使之包含在下次提交的快照中。已提交表示数据已安全的保存在了本地数据库中。\n 安装Git 略\n Git初始配置 Git自带一个 git config 工具来帮助设置控制 Git 外观和行为的配置变量。这些变量主要存储在三个地方：\n /etc/gitconfig 文件：配置针对所有用户。在执行 git config 时带上 \u0026ndash;system选项，就会读写此文件中的配置。 ~/.gitconfig 或 ~/.config/git/config 文件：配置只针对当前用户。可以传递 \u0026ndash;global 选项让 Git 读写此文件。 当前仓库的 Git 目录中的 config 文件（即 .git/config ）：配置针对当前仓库。可以传递 \u0026ndash;local 选项让 Git 强制读写此文件，同时默认情况下也是读取的此文件。  这三个级别的配置都会覆盖上一级的配置，即当前仓库自定义配置优先级最高。\n用户信息 1 2  git config --global user.name \u0026#34;Any Tom\u0026#34; git config --global user.email anytom@example.com   文本编辑器 Git 需要用户输入信息时会调用系统默认的编辑器，如果想使用不同的，可以自己配置：\n1  git config --global core.edit code   ⚠️在 Windows 系统上，如果想使用别的文本编辑器，必须指定完整的可执行文件路径\n查看配置信息 列出所有 Git 当时能找到的配置\n1  git config --list   查看某一项配置\n1  git config user.name   由于 Git 会从不同的配置文件中读取同一配置变量的值，因此有些时候可能会看到意料之外的值而不知道为啥。此时可以用命令查看该变量的原始值，命令会告诉你是哪一个配置文件最后设置了该值：\n1  git config --show-origin user.name    获取帮助 在使用 Git 时，有三种等价的方法可以找到 Git 命令的综合手册：\n1 2 3  git help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help man git-\u0026lt;verb\u0026gt;   如果不需要全面的手册，只需要可用选项的快捷参考，可用 git \u0026lt;verb\u0026gt; -h 来获取更简明的“help”输出。\n Git基础 本章主要内容：Git 使用过程中的各种基本命令。\n 获取 Git 仓库 通常获取 Git 的方式有两种：\n 将尚未进行版本控制的本地目录转为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。  从本地目录初始化仓库 1 2  cd /my_project_path git init   以上命令将创建一个名为 .git 的子目录，目录中包含了初始化 Git 仓库所有的必须文件。此命令执行后只是初始化了一个 Git 仓库，项目中已有的文件不会被跟踪，此时需要开始追踪并进行初始提交。\n1 2 3  git add *.c git add LICENSE git commit -m \u0026#39;提交消息内容\u0026#39;   克隆现有仓库 1  git clone \u0026lt;url\u0026gt; \u0026lt;自定义本地仓库名 可选\u0026gt;   克隆仓库时，支持 http(s):// 协议， git:// 协议 或者 SSH 传输协议。\n 记录每次更新到仓库 Git 中文件的变化周期：\n检查当前文件状态 1  git status   此命令会显示当前哪些文件处于什么状态。列出未跟踪、\n跟踪新文件 1  git add \u0026lt;fileName\u0026gt;   暂存已修改的文件 1  git add \u0026lt;fileName\u0026gt;   可以看到，新文件的跟踪、已修改文件的暂存都使用 add 操作，所以 add 操作实际上应该理解为：将指定内容标记为待提交状态（放到暂存区）；若暂存后的文件被修改，必须重新 add，否则 git commit 只会提交上次 add时的状态。\n批量操作：\n1 2 3  git add -A # 提交所有变化 git add -u # 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . # 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件   状态简览 1 2  git status --short git status -s   git status 命令的输出十分的详细，实际上我们可能并不需要，通过上面的命令，可以得到简洁的状态信息。\n1 2 3 4 5 6  $ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.tx   M 表示文件已修改，MM 表示文件暂存后又有修改，A 表示文件是新增的，?? 表示文件未跟踪。在简览时，未暂存的修改和已暂存的修改标识符号一样，但是颜色不同。\n忽略文件 无需纳入 Git 跟踪的文件记录在 .gitignore中\n提交更新 1  git commit   在 commit 时，Git 会启动编辑器来输入提交说明，使用 git commit -m '提交说明' 可以直接输入提交说明。\n跳过使用暂存区域 1  git commit -a   使用此命令 Git 会自动把所有已跟踪的文件暂存起来一并提交，从而跳过 git add 步骤。\n移除文件 从 Git 中移除文件：必须要从已跟踪文件清单中移除，然后提交。Git 提供了 git rm 命令，可完成删除文件并将删除操作放入暂存区的操作。如果删除的文件已经修改过，直接 rm 会报错（不论有没有提交到暂存区，都会报错），此时需要使用 git rm -f 命令。如果只是想把某文件从版本库中删除，本地磁盘保留，则需要命令 git rm --cached。\n移动文件 Git 不像其它的一些 VCS 一样支持显式的跟踪文件移动操作。如果要重命名文件，需要用到以下命令：\n1  git mv file_from file_to    查看提交历史 1  git log    撤销操作 上次提交少了几个文件的情况 1  git commit --amend   此命令会将当前暂存区中的操作追加上次提交中（最终仓库只显示一次提交记录）。\n取消暂存的操作 1  git reset HEAD \u0026lt;file\u0026gt;   文件修改还保留在本地磁盘，只是不在暂存区。\n撤销对文件的修改 1  git restore \u0026lt;文件\u0026gt;...   此操作 Git 会用仓库中最近一次提交的版本覆盖本地文件，文件在本地磁盘上的修改会全部被删除（不可通过 Git 恢复）。\n 远程仓库的使用 查看远程仓库对应的简写和对应的 URL。 1  git remote -v   添加远程仓库并指定一个方便使用的简写 1  git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt;   指定shortname之后就可以用shortname来代替整个 URL。例如：\n1  git fetch \u0026lt;shortname\u0026gt;   从远程仓库中抓取与拉取 1  git fetch \u0026lt;remote\u0026gt;   此命令只会将最新数据下载到本地仓库，但是不会自动合并，需要手动操作。如果使用 git pull 命令，则会从服务器抓取数据，并尝试自动合并到当前所在的分支。\n推送到远程仓库 1 2  # git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; git push orgin master   如果在你 push 之前，有人 push 过，那就要先将他人的 push pull 下来进行合并，然后才能 push。\n查看某个远程仓库 1  git remote show \u0026lt;remote\u0026gt;    打标签 打标签功能用于给仓库的某一个提交打上标签，以示重要。常用这个功能来标记发布结点\n列出标签 1  git tag # 可带上 -l 或 --list   创建标签 附注标签 1  git tag -a v1.0 -m \u0026#34;版本1.0\u0026#34;   轻量标签 1  git tag v1.1   后期打标签 若某个版本已提交，但是忘了打标签，可以通过 git log 命令找到那个版本的校验和，然后执行命令：\n1  git tag -a v0.1 \u0026lt;校验和 可以只输入部分\u0026gt;   共享标签 默认情况下，push 时并不会传送标签到远程仓库，需要显式的推送。\n1 2 3 4  # 单个标签推送 git push origin \u0026lt;tagname\u0026gt; # 批量推送，会把所有不在远程仓库的标签全部推送上去 git push origin --tags   删除标签 1 2 3 4 5 6 7  # 第一步 git tag -d v0.1 # 第二步 # 将冒号前的空值推送到远程标签 git push \u0026lt;remote\u0026gt; :refs/tags/v0.1 # 还可写为 git push \u0026lt;remote\u0026gt; --delete v0.1    技巧和窍门 Git 别名 1 2 3 4  $ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.ci commit $ git config --global alias.st status   在 git commit 时 只需要 git ci\n ","date":"2021-03-10T22:55:00+08:00","permalink":"https://io-oss.gitee.io/blog/p/a0fa4610/","title":"Pro Git"},{"content":" 开始系统的学习Java基础知识\n 第1章 Java程序设计概述 Java发展简史    版本 年份 语言新特性 类与接口的数量     1.0 1996 语言本身 211   1.1 1997 内部类 477   1.2 1998 strictfp修饰符 1524   1.3 2000 无 1840   1.4 2002 断言 2723   5.0 2004 泛型类、“for each”循环、可变元参数、自动装箱、元数据、枚举、静态导入 3279   6 2006 无 3793   7 2011 基于字符串的switch、钻石操作符、二进制字面量、异常处理改进 4024   8 2014 lambda表达式、包含默认方法的接口、流和日期/时间库 4240    注：当前已发布到版本16\nJava“白皮书”的关键术语  简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  第2章 Java程序设计环境 安装Java开发工具包（JDK） 相关术语\n   术语名 缩写 解释     Java Development Kit JDK 编写Java程序的程序员使用的软件   Java Runtime Environment JRE 运行Java程序的用户使用的软件   Server JRE —— 在服务器上运行Java程序的软件   Standard Edition SE 用于桌面或简单服务器应用的Java平台   Enterprise Edition EE 用于复杂服务器应用的Java平台   Micro Edition ME 用于手机和其它小型设备的Java平台   Java FX —— 用于图形化用户界面的一个替代工具包，在Oracle的Java SE发布版本中提供   OpenJDK —— Java SE的一个免费开源实现，不包含浏览器集成或JavaFX   Java 2 J2 一个过时的术语，用于描述1998年～2006年之间的Java版本   Software Development Kit SDK 一个过时的术语，用于描述1998年～2006年之间的JDK   Update u Oracle的术语，表示bug修正版本   Netbeans —— Oracle的集成开发环境     这两章简单介绍了Java的一些特点、发展历史和学习Java编程的前期准备工作，接下来开始正式的内容\n 第3章 Java的基本程序设计结构 一个简单的 Java 应用程序 1 2 3 4 5 6 7  public class FirstSample { public static void main(String args) { System.out.println(“We will not use ‘Hello World!‘“); } }   类名必须以大写字母开头，遵循骆驼命名法。文件名必须与公共类名一致。\n注释 单行注释\n1 2  //这是单行注释 System.out.println(“Hello World!“);   多行注释\n1 2 3 4 5  /* 这是多行注释的示例 这是多行注释的示例 */ System.out.println(“Hello World!“);   文档注释\n1 2 3  /** *文档注释的写法 */   数据类型 Java 是一种强类型语言，每个变量都必须声明类型。Java 共有 8 种基本类型，包含 4 种整型、两种浮点类型、1 种用于表示 Unicode 编码字符单元的字符类型 char。\n   基本类型 位数 字节 默认值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   char 16 2 \u0026lsquo;u0000\u0026rsquo;   float 32 4 0f   double 64 8 0d   boolen 1  false    变量 声明变量与初始化 1  String name = \u0026#34;名字\u0026#34;;   常量 常量即用final关键字修饰的变量，表示这个变量只能被赋值一次。常量名习惯全大写。\n","date":"2021-03-04T23:27:31+08:00","permalink":"https://io-oss.gitee.io/blog/p/a8e95393/","title":"Java核心技术·卷I"},{"content":" 写作时所有标记用的符号都要用英文，文章标点随意\n  标题 语法 #加文字\n1 2 3 4 5 6 7  # 一级标题 ## 二级标题 ### 三级标题 . . . ###### 六级标题   效果\n一般一级标题是文章的名称，所以在博客中的标题常从二级开始\n 列表 无序列表 语法 -加空格加文字\n1 2 3 4 5  - 列表1 - 列表1.1 - 列表1.2 - 列表2 - 列表3   效果\n有序列表 语法 数字加.(英文句号)加空格加文字\n1 2 3 4 5  1. 列表1 1. 列表1.1 1. 列表1.2 1. 列表2 1. 列表3   列表中数字并不需要自己一个个排序，全写1即可自动生成序号\n效果\n 引用 语法 \u0026gt;加空格加引用内容，多行每行都加\n1 2 3 4  \u0026gt; 登鹳雀楼_百度汉语 \u0026gt; 作者：王之涣 \u0026gt; 白日依山尽，黄河入海流。 \u0026gt; 欲穷千里目，更上一层楼。   效果\n 文字强调 粗体 语法 **要加粗的文字** 或者用_\n1  **文字**   效果\n粗体\n斜体 语法 *要变斜体的文字* 或者用_\n1  *文字*   效果\n斜体\n下划线 语法\n1  \u0026lt;u\u0026gt;文字\u0026lt;/u\u0026gt;   效果\n下划线\n删除线 语法\n1 2  # ~ 英文输入法状态下 Shift 加 ESC下面的按键 ~~文字~~   效果\n删除线\n 分割线 语法\n1  ***   效果  图片 语法\n1  ![名称·随便写](图片地址)    网址 语法\n1  [显示名称](网址)   效果\n百度\n 表格 语法\n1 2 3 4 5  | | | | | :--- | :--: | ---: | | | | | | | | | | | | |   说明\n1 2 3 4 5 6  # 两个｜｜之间是一列，需要几列就分隔出来几个 | | | |这一行是表头 | :--- | :--: | ---: |这一行是显示控制行：列左对齐则冒号在左，右对齐冒号在右，居中则两头冒号 | | | |以下行是表格内容，有几行就加几个，单元格内容放在｜｜中间 | | | | | | | |   效果\n   表头 表头 表头     4 5 6   7 8 9   10 11 12    ","date":"2021-03-02T11:59:39+08:00","permalink":"https://io-oss.gitee.io/blog/p/b133175a/","title":"Markdown语法简单教程"},{"content":"杭州市限行政策查询  ","date":"2021-02-25T09:08:02+08:00","permalink":"https://io-oss.gitee.io/blog/p/7ecba2d8/","title":"杭州市限行信息"},{"content":"南阳市限行政策查询  ","date":"2021-02-24T20:07:13+08:00","permalink":"https://io-oss.gitee.io/blog/p/2c7767a8/","title":"南阳市限行信息"},{"content":" 使用 hugo new 新建页面时创建的页面由 archetypes/default.md决定\n 说明 永久链接的生成方案是比较简单的，直接对时间 + 文章名生成字符串做一下 md5 然后取任意 4-12 位即可。这样做的话 md5 冲撞概率极小，同时也没有那么大的运算负担。而 Hugo 在永久链接中支持下面这个参数：slug。简单来说，我们可以针对每一篇文章指定一个 slug，然后在 config.toml 中配置 permalinks 包含 slug 参数，就可以生成唯一的永久链接。我们的目的就是对每篇文章自动生成一个 slug。\n操作 修改 archetypes/default.md 添加如下一行：\n1 2 3 4 5  ---#...slug:{{substr (md5 (printf \u0026#34;%s%s\u0026#34; .Date (replace .TranslationBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title))) 4 8 }}#...---   参考：Hugo 永久链接\n ","date":"2021-02-24T00:53:53+08:00","permalink":"https://io-oss.gitee.io/blog/p/da23b91d/","title":"Hugo永久链接"},{"content":"实现思路  在一个在线页面内实现拨号逻辑 生成步骤1中的页面地址对应的二维码 设计步骤2中二维码的样式，打印出来  拨号界面简单实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;renderer\u0026#34; content=\u0026#34;webkit\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;force-rendering\u0026#34; content=\u0026#34;webkit\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;一键拨号\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;方便、简单、实用\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;联系我挪车\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;margin-top:50px\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;临时停车😊请多关照\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;tel:{{手机号码}}\u0026#34; class=\u0026#34;btn btn-success btn-lg\u0026#34; style=\u0026#34;font-size:35px;margin-top:20px;\u0026#34;\u0026gt;挪车电话\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;margin-top:50px\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    页面的托管是很容易解决的，Gitee、GitHub都有提供pages服务，国内推荐用gitee\n 效果展示 ","date":"2021-02-23T12:25:05+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210228015227.jpeg","permalink":"https://io-oss.gitee.io/blog/p/1a22f05b/","title":"二维码挪车牌"},{"content":"说明 文章中的快捷键针对Windows10，其它版本Windows系统可能不生效\n快捷键    键位 功能     ctrl+c 复制   ctrl+v 粘贴   ctrl+z 撤销   ctrl+a 全选   ctrl+s 保存   ctrl+x 剪切   ctrl+f 查找   ctrl+tab 切换浏览器、文件管理器等多标签软件标签页   ctrl+w 关闭浏览器、文件管理器等多标签软件的当前页面或单窗体软件   ctrl+shift+t 恢复刚关闭的浏览器页面   ctrl+t 创建一个新浏览器标签页   ctrl++ 放大（浏览器、图片浏览、桌面等处都可用）   ctrl+- 缩小（浏览器、图片浏览、桌面等处都可用）   ctrl+alt+delete 打开任务管理器界面   ctrl+p 打印当前文件       win+d 回到桌面（不论打开了多少窗体）   win+L 锁定电脑   win+e 打开文件管理器   win+m 最小化当前窗体   win+数字键 打开固定在任务栏对应顺序的应用    ","date":"2021-02-22T17:17:12+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210222164440.png","permalink":"https://io-oss.gitee.io/blog/p/a2e6bc04/","title":"Windows快捷键"},{"content":"表象 成因 Gitalk默认的GitHub oauth请求反向代理CORS使用的是https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_tokenGitHub项目，该代理只是一个演示项目，由于被滥用，作者决定于2021年1月31日停止开放使用，从而导致了此问题的产生\n解决  在Heroku上部署自己的cros-anywhere\n   1.注册Heroku账号\n  2.fork cros-anywhere项目\n  3.创建Heroku应用\n  4.将自己fork的项目部署创建的Heroku应用\n官方文档 实际上自己通过网页端操作更方便点\n  5.设置白名单防止滥用导致封号\n  6.修改主题中Gitalk相关的代码 增加Gitalk反向代理配置项\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 修改主题根目录下config.json文件，增加Gitalk反向代理自定义配置节点，用于自定义配置代理地址 { \u0026#34;customConfig\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gitalkProxy\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;GitHub登陆\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;Gitalk\u0026#34;, //此处将地址配置成自己的代理服务器  \u0026#34;value\u0026#34;: \u0026#34;https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;note\u0026#34;: \u0026#34;GitHub验证\u0026#34; } ] }   修改Gitalk初始化代码templates/includes/gitalk.ejs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;script\u0026gt; window.onload = function() { var gitalk = new Gitalk({ //增加代理参数，赋值读取自定义配置  proxy: \u0026#39;\u0026lt;%= site.customConfig.gitalkProxy %\u0026gt;\u0026#39;, clientID: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.clientId %\u0026gt;\u0026#39;, clientSecret: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.clientSecret %\u0026gt;\u0026#39;, repo: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.repository %\u0026gt;\u0026#39;, owner: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.owner %\u0026gt;\u0026#39;, admin: [\u0026#39;\u0026lt;%= commentSetting.gitalkSetting.owner %\u0026gt;\u0026#39;], id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50  distractionFreeMode: false // Facebook-like distraction free mode  }) gitalk.render(\u0026#39;gitalk-container\u0026#39;) } \u0026lt;/script\u0026gt;   ","date":"2021-02-20T17:59:56+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210220214315.png","permalink":"https://io-oss.gitee.io/blog/p/44c1c716/","title":"Gridea Gitalk 评论登录403问题"},{"content":"Nuget包管理加载版本时报错 解决方案：\n 打开.vscode/extensions/jmrog.vscode-nuget-package-manager-1.1.6/out/src/actions/add-methods/fetchPackageVersions.js， 修改代码 1  ...node_fetch_1.default(`${versionsUrl}${selectedPackageName.toLowerCase()}/index.json`, utils_1.getFetchOptions(vscode.workspace.getConfiguration(\u0026#39;http\u0026#39;)))     ","date":"2021-02-06T13:19:30+08:00","permalink":"https://io-oss.gitee.io/blog/p/41e58ada/","title":"Visual Studio Code 使用问题记录"},{"content":" 借用百度地图 API 进行坐标系转换\n 代码详情 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163  #!/usr/bin/python3 # -*- coding: utf-8 -*- import json import requests import math key = \u0026#39;your key here\u0026#39; # 这里填写你的百度开放平台的key x_pi = 3.14159265358979324 * 3000.0 / 180.0 pi = 3.1415926535897932384626 # π a = 6378245.0 # 长半轴 ee = 0.00669342162296594323 # 扁率 def geocode(address): \u0026#34;\u0026#34;\u0026#34; 利用百度geocoding服务解析地址获取位置坐标 :param address:需要解析的地址 :return: \u0026#34;\u0026#34;\u0026#34; geocoding = {\u0026#39;s\u0026#39;: \u0026#39;rsv3\u0026#39;, \u0026#39;key\u0026#39;: key, \u0026#39;city\u0026#39;: \u0026#39;全国\u0026#39;, \u0026#39;address\u0026#39;: address} res = requests.get( \u0026#34;http://restapi.amap.com/v3/geocode/geo\u0026#34;, params=geocoding) if res.status_code == 200: json = res.json() status = json.get(\u0026#39;status\u0026#39;) count = json.get(\u0026#39;count\u0026#39;) if status == \u0026#39;1\u0026#39; and int(count) \u0026gt;= 1: geocodes = json.get(\u0026#39;geocodes\u0026#39;)[0] lng = float(geocodes.get(\u0026#39;location\u0026#39;).split(\u0026#39;,\u0026#39;)[0]) lat = float(geocodes.get(\u0026#39;location\u0026#39;).split(\u0026#39;,\u0026#39;)[1]) return [lng, lat] else: return None else: return None def gcj02tobd09(lng, lat): \u0026#34;\u0026#34;\u0026#34; 火星坐标系(GCJ-02)转百度坐标系(BD-09) 谷歌、高德——\u0026gt;百度 :param lng:火星坐标经度 :param lat:火星坐标纬度 :return: \u0026#34;\u0026#34;\u0026#34; z = math.sqrt(lng * lng + lat * lat) + 0.00002 * math.sin(lat * x_pi) theta = math.atan2(lat, lng) + 0.000003 * math.cos(lng * x_pi) bd_lng = z * math.cos(theta) + 0.0065 bd_lat = z * math.sin(theta) + 0.006 return [bd_lng, bd_lat] def bd09togcj02(bd_lon, bd_lat): \u0026#34;\u0026#34;\u0026#34; 百度坐标系(BD-09)转火星坐标系(GCJ-02) 百度——\u0026gt;谷歌、高德 :param bd_lat:百度坐标纬度 :param bd_lon:百度坐标经度 :return:转换后的坐标列表形式 \u0026#34;\u0026#34;\u0026#34; x = bd_lon - 0.0065 y = bd_lat - 0.006 z = math.sqrt(x * x + y * y) - 0.00002 * math.sin(y * x_pi) theta = math.atan2(y, x) - 0.000003 * math.cos(x * x_pi) gg_lng = z * math.cos(theta) gg_lat = z * math.sin(theta) return [gg_lng, gg_lat] def wgs84togcj02(lng, lat): \u0026#34;\u0026#34;\u0026#34; WGS84转GCJ02(火星坐标系) :param lng:WGS84坐标系的经度 :param lat:WGS84坐标系的纬度 :return: \u0026#34;\u0026#34;\u0026#34; if out_of_china(lng, lat): # 判断是否在国内 return lng, lat dlat = transformlat(lng - 105.0, lat - 35.0) dlng = transformlng(lng - 105.0, lat - 35.0) radlat = lat / 180.0 * pi magic = math.sin(radlat) magic = 1 - ee * magic * magic sqrtmagic = math.sqrt(magic) dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi) dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi) mglat = lat + dlat mglng = lng + dlng return [mglng, mglat] def gcj02towgs84(lng, lat): \u0026#34;\u0026#34;\u0026#34; GCJ02(火星坐标系)转GPS84 :param lng:火星坐标系的经度 :param lat:火星坐标系纬度 :return: \u0026#34;\u0026#34;\u0026#34; if out_of_china(lng, lat): return lng, lat dlat = transformlat(lng - 105.0, lat - 35.0) dlng = transformlng(lng - 105.0, lat - 35.0) radlat = lat / 180.0 * pi magic = math.sin(radlat) magic = 1 - ee * magic * magic sqrtmagic = math.sqrt(magic) dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi) dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi) mglat = lat + dlat mglng = lng + dlng return [lng * 2 - mglng, lat * 2 - mglat] def transformlat(lng, lat): ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \\ 0.1 * lng * lat + 0.2 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lat * pi) + 40.0 * math.sin(lat / 3.0 * pi)) * 2.0 / 3.0 ret += (160.0 * math.sin(lat / 12.0 * pi) + 320 * math.sin(lat * pi / 30.0)) * 2.0 / 3.0 return ret def transformlng(lng, lat): ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \\ 0.1 * lng * lat + 0.1 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lng * pi) + 40.0 * math.sin(lng / 3.0 * pi)) * 2.0 / 3.0 ret += (150.0 * math.sin(lng / 12.0 * pi) + 300.0 * math.sin(lng / 30.0 * pi)) * 2.0 / 3.0 return ret def out_of_china(lng, lat): \u0026#34;\u0026#34;\u0026#34; 判断是否在国内，不在国内不做偏移 :param lng: :param lat: :return: \u0026#34;\u0026#34;\u0026#34; if lng \u0026lt; 72.004 or lng \u0026gt; 137.8347: return True if lat \u0026lt; 0.8293 or lat \u0026gt; 55.8271: return True return False if __name__ == \u0026#39;__main__\u0026#39;: lng = 128.543 lat = 37.065 result1 = gcj02tobd09(lng, lat) result2 = bd09togcj02(lng, lat) result3 = wgs84togcj02(lng, lat) result4 = gcj02towgs84(lng, lat) result5 = geocode(\u0026#39;北京市朝阳区朝阳公园\u0026#39;) print(result1, \u0026#39;\\n\u0026#39;, result2, \u0026#39;\\n\u0026#39;, result3, \u0026#39;\\n\u0026#39;, result4, \u0026#39;\\n\u0026#39;, result5)   ","date":"2021-02-05T13:13:42+08:00","permalink":"https://io-oss.gitee.io/blog/p/2a125715/","title":"坐标系转换"},{"content":"实现步骤  整体逻辑：使用GitHub仓库作为存储空间，利用jsdeliver做CDN，利用PicGo做图片管理工具\n 1. Github设置  创建公开仓库 创建私人访问Token,并将Token记录下来   注意：Token需要有repo、delete_repo权限\n 2. PicGo设置 配置如下\n资源 PicGo\njsDelivr\n","date":"2021-02-04T17:09:16+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210204215131.png","permalink":"https://io-oss.gitee.io/blog/p/4063f65b/","title":"Github+PicGo+jsdeliver搭建图床"},{"content":" 转载自：Windows下Oracle定时备份(全量备份)\n 关于Windows下oracle全量备份的文章，很多网站都有，写下本文不过是为了以后方便查找，不用再到处找。以下些许内容有所参考到其他人所写内容，这里无意冒犯，本文引用内容部分会附上参考地址，还望原作者见谅。\n备份脚本 新建txt文档，把脚本复制进去后改文件格式为bat文件，双击运行即可测试该脚本是否有误。这里要说明一下，开始把脚本拿过来执行时，一直未能成功备份数据库,用bat的pause暂停调试发现了一些问题，有时不注意可能会在定义,变量如BACKUPDATE、USER等后面带了空格,这个时候问题就来了，导致参数的不正确，所以这里需注意！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @echo off echo ================================================ echo Windows环境下Oracle数据库的自动备份脚本 echo 1. 使用当前日期命名备份文件。 echo 2. 自动删除7天前的备份。 echo ================================================ echo 以“YYYYMMDD”格式取出当前时间。 set BACKUPDATE=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2% echo 设置用户名、密码和要备份的数据库 set USER=ora_user set PASSWORD=ora_name set DATABASE=conn_db echo 创建备份目录 if not exist \u0026#34;E:\\backup\\data\u0026#34; mkdir E:\\backup\\data if not exist \u0026#34;E:\\backup\\log\u0026#34; mkdir E:\\backup\\log set DATADIR=E:\\backup\\data set LOGDIR=E:\\backup\\log exp %USER%/%PASSWORD%@%DATABASE% file=%DATADIR%\\data_%BACKUPDATE%.dmp log=%LOGDIR%\\log_%BACKUPDATE%.log echo 删除7天前的备份。 forfiles /p \u0026#34;%DATADIR%\u0026#34; /s /m *.* /d -7 /c \u0026#34;cmd /c del @path\u0026#34; forfiles /p \u0026#34;%LOGDIR%\u0026#34; /s /m *.* /d -7 /c \u0026#34;cmd /c del @path\u0026#34; exit    注：该脚本参考Windows环境下Oracle数据库的自动备份脚本\n 定时任务 这里需要用到Windows的【任务计划程序】，操作按照下列截图一一操作。\n快捷查询 选择任务计划程序 创建基本任务 填写任务相关信息 定时任务描述 任务执行时间 选择刚刚写的数据库备份脚本\n最后在任务列表里可以看到刚刚创建的定时任务，那么这个任务从设定的时间开始则会每天执行一次，即达到定时备份任务了\n 注：以上内容参考 定时备份ORACLE数据库(windows环境下)\n 脚本 定时备份.txt\n","date":"2020-12-25T14:38:32+08:00","permalink":"https://io-oss.gitee.io/blog/p/22637e0b/","title":"Oracle定时备份"},{"content":"环境 1 2  # 需要装好 ffmpeg brew install ffmpeg   脚本 1 2 3 4 5  # 文字转语音 say -f 1.txt -o 1.aiff say 你好 -o 你好.aiff # 音频格式转换 ffmpeg -f aiff -i 你好.aiff 你好.mp3   ","date":"2020-10-06T13:48:54+08:00","permalink":"https://io-oss.gitee.io/blog/p/0272ad7a/","title":"文字转语音"},{"content":"期待一下 \r\r","date":"2020-08-20T11:26:07+08:00","permalink":"https://io-oss.gitee.io/blog/p/a39f146f/","title":"黑神话·悟空"},{"content":"哈哈哈 ","date":"2020-08-06T21:35:01+08:00","permalink":"https://io-oss.gitee.io/blog/p/4a241902/","title":"今天天气很是不错..."},{"content":" Homebrew\n 查看已安装的包 查看已经安装的包\n1  brew list   更新Homebrew 更新Homebrew(此命令会显示可以更新的包列表，已安装的包会有对号)\n1  brew update   列出可更新的包 1 2 3 4  # 不包含含自动更新的包 brew outdated # 含自动更新的包 brew cask outdated --greedy   安装更新 1  brew upgrade   清理旧版本 1 2 3 4 5 6 7 8  # 查看可清理的包列表 brew cleanup -n # 清理旧版本包 brew cleanup # 清理早于3天的无用的symlink，且清理与之相关的位于/Applications和~/Applications中的无用App链接 brew cleanup --prune 3   ","date":"2020-07-06T13:46:40+08:00","permalink":"https://io-oss.gitee.io/blog/p/319d5434/","title":"Homebrew"},{"content":"命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 查看系统激活状态 slmgr.vbs -xpr # 查看系统激活状态详细信息 slmgr.vbs -dlv # 安装产品密钥（企业版Key） slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX # 设置KMS服务器 slmgr /skms 192.168.31.57:1688 # 自动激活 slmgr /ato   密钥 1  W269N-WFGWX-YVC9B-4J6C9-T83GX   资源 KMS服务器\n","date":"2019-08-13T13:54:20+08:00","permalink":"https://io-oss.gitee.io/blog/p/acf0469c/","title":"Windows KMS激活"},{"content":"连肝了好多天 ","date":"2018-11-04T03:10:03+08:00","permalink":"https://io-oss.gitee.io/blog/p/14cff628/","title":"拿到 [真·大师剑] 了"},{"content":"见习猎人 --  Your browser doesn't support HTML5 video. Here is a link to the video instead.   ","date":"2018-09-16T15:49:07+08:00","permalink":"https://io-oss.gitee.io/blog/p/0b3c6886/","title":"一种从天而降的棒法"},{"content":"第一次见到时确实吓了一跳  Your browser doesn't support HTML5 video. Here is a link to the video instead.   -- ","date":"2018-09-14T22:58:33+08:00","permalink":"https://io-oss.gitee.io/blog/p/ca48c2fa/","title":"目击了一条龙"},{"content":"骑行 和几个小伙伴骑共享单车跑了20多公里。景区应该是还没有开发完毕，设施很不完善，人很少。不过跑的还是很开心。\n景区 ","date":"2018-03-10T21:04:54+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210228015926.jpeg","permalink":"https://io-oss.gitee.io/blog/p/343d7f9e/","title":"西山国家森林公园灵山风景区"}]